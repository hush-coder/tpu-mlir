#!/bin/bash
# Usage description
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
usage() {
    echo "Usage: \$0 -f <header_file> -d <source_dir>"
    echo "  -f <header_file>: path to the header file containing FW_LAYER_TYPE_T definitions"
    echo "  -d <build_dir>: build directory path (default: $SCRIPT_DIR/build)"
    exit 1
}

header_file="${PROJECT_ROOT}/include/tpu_mlir/Dialect/Tpu/Transforms/Codegen/Dynamic/DynCompileCommon.hpp"
build_dir="$SCRIPT_DIR/build"
while getopts ":f:d:" opt; do
    case $opt in
        f) header_file="$OPTARG" ;;
        d) build_dir="${SCRIPT_DIR}/$OPTARG" ;;
        \?) echo "Invalid option -$OPTARG" >&2; usage ;;
        :) echo "Option -$OPTARG requires an argument." >&2; usage ;;
    esac
done
source_dir=${build_dir}/device
output_file=$SCRIPT_DIR/include/ppl_dyn_fw.h

if [ ! -d "$source_dir" ]; then
    echo "Error: Source directory $source_dir does not exist"
    exit 1
fi

if [ ! -f "$header_file" ]; then
echo "Error: Header file $header_file not found"
exit 1
fi

# Find the value of FW_LAYER_UNKNOWN in the FW_LAYER_TYPE_T and set start_idx
unknown_val=$(
sed -n '/typedef[[:space:]]\+enum[[:space:]]\+fw_layer_type[[:space:]]*{/,/}[[:space:]]*FW_LAYER_TYPE_T[[:space:]]*;/p' \
    "$header_file" \
| grep -E 'FW_LAYER_UNKNOWN[[:space:]]*=' \
| head -1 \
| grep -Eo '[0-9]+'
)
if [ -n "$unknown_val" ]; then
  start_idx=$(( unknown_val + 1 ))
else
  echo -e "\033[1;31mERRO: FW_LAYER_UNKNOWN not found in FW_LAYER_TYPE_T\033[0m"
  exit 1
fi
# Gather all functions matching the "int xxx(const void *args)""
func_list=$(
  find "$source_dir" -type f -name "*.c" \
    -exec grep -Pho 'int \K\w+(?=\(const void \s*\*\s*args\))' {} + \
    | sort -u
)
# Generate the ppl_dyn_fw.h
header_guard=$(echo "${output_file##*/}" | tr '[:lower:].' '[:upper:]_')
cat > "$output_file" <<EOF
// Auto-generated function type enum
// DO NOT EDIT - Generated by $0

#ifndef ${header_guard}
#define ${header_guard}
#include <stddef.h>
#include <stdint.h>

typedef enum ppl_fw_layer_type {
EOF
# generate all PPL_FW_LAYER_TYPE_T enum values
idx=$start_idx
while IFS= read -r func_name; do
  enum_name=$(echo "$func_name" \
    | sed 's/[^a-zA-Z0-9]/_/g' \
    | tr '[:lower:]' '[:upper:]')
  printf "  PPL_FW_%s = %d,\n" "$enum_name" "$idx" >> "$output_file"
  ((idx++))
done <<< "$func_list"
cat >> "$output_file" <<EOF
  PPL_FW_LAYER_TYPE_UNKNOWN = $idx,
} PPL_FW_LAYER_TYPE_T;
EOF
# generate init function
cat >> "$output_file" <<'EOF'
// func map
static int ppl_func_map_inited = 0;
static void *ppl_local_func_map[PPL_FW_LAYER_TYPE_UNKNOWN] = {NULL};
static void *ppl_global_func_map[PPL_FW_LAYER_TYPE_UNKNOWN] = {NULL};

#define __DYNAMIC_FUNC_BIND_MAP(m, t, v) m##_map[(t)]  = (v)

#define LOCAL_FUNC_BIND(t, v) __DYNAMIC_FUNC_BIND_MAP(ppl_local_func, t, v)
#define GLOBAL_FUNC_BIND(t, v) __DYNAMIC_FUNC_BIND_MAP(ppl_global_func, t, v)

void fw_init_ppl_func_map();
#endif
EOF

# Check for missing definitions
# Extract all FW_LAYER_TYPE_T enum values from the original header file
awk '/typedef enum fw_layer_type {/,/} FW_LAYER_TYPE_T;/' "$header_file" | 
grep -Eo '^[[:space:]]*PPL_[A-Z0-9_]+[[:space:]]*=[[:space:]]*[0-9]+' | 
sort -u > existing_enums.tmp

# Check if each generated PPL_FW_LAYER_TYPE_T enum already exists
missing_count=0
while read -r new_enum; do
  if ! grep -q "^[[:space:]]*${new_enum}$" existing_enums.tmp; then
    echo "$new_enum,"
    (( missing_count++ ))
  fi
done < <(
  grep -Eo '^[[:space:]]*PPL_[A-Z0-9_]+[[:space:]]*=[[:space:]]*[0-9]+' "$output_file"
)

rm -f existing_enums.tmp
if [ "$missing_count" -gt 0 ]; then
    echo -e "\n\033[1;35mTotal missing definitions: $missing_count\033[0m"
    echo -e "\033[1;31mERROR: Add above definitions to $header_file and rebuild tpu-mlir\033[0m"
    exit 1 
fi
echo "Ppl dyn layer definitions is write to: $output_file"